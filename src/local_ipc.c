
#include "zpc/local_ipc.h"

#include "zpc/fatal.h"

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>

struct local_ipc_peer_zt
{
    int socket_fd;
    bool is_server;
    char* socket_path;
    int connection_fd;
    bool connected;
};

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_init_z: Initialize a local IPC peer as either server or client.
// Fatal on error. Returns a handle to the peer.
// =========================================================================================================================================
// =========================================================================================================================================
local_ipc_peer_zh local_ipc_init_z(const char* socket_path, bool server)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(socket_path, "socket_path is null");
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    struct local_ipc_peer_zt* peer = (struct local_ipc_peer_zt*)fatal_alloc_z(sizeof(struct local_ipc_peer_zt), "failed to allocate local_ipc_peer");
    {
        peer->is_server     = server;
        peer->socket_fd     = -1;
        peer->connection_fd = -1;
        peer->connected     = false;
    }

    // =============================================================================================
    // =============================================================================================
    // Store socket path.
    // =============================================================================================
    // =============================================================================================
    {
        size_t path_len   = strlen(socket_path);
        peer->socket_path = (char*)fatal_alloc_z(path_len + 1, "failed to allocate socket_path");
        memcpy(peer->socket_path, socket_path, path_len + 1);
    }

    // =============================================================================================
    // =============================================================================================
    // Create Unix domain socket.
    // =============================================================================================
    // =============================================================================================
    {
        peer->socket_fd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
        if (peer->socket_fd < 0)
        {
            fatal_z("failed to create Unix domain socket: %s", strerror(errno));
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Setup socket address structure.
    // =============================================================================================
    // =============================================================================================
    struct sockaddr_un addr;
    {
        memset(&addr, 0, sizeof(addr));
        addr.sun_family = AF_UNIX;
        strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);
        addr.sun_path[sizeof(addr.sun_path) - 1] = '\0';
    }

    // =============================================================================================
    // =============================================================================================
    // Initialize server or client.
    // =============================================================================================
    // =============================================================================================
    {
        if (server)
        {
            if (unlink(socket_path) != 0 && errno != ENOENT)
            {
                fatal_z("failed to unlink existing socket: %s", strerror(errno));
            }

            if (bind(peer->socket_fd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
            {
                fatal_z("failed to bind socket: %s", strerror(errno));
            }

            if (listen(peer->socket_fd, 1) != 0)
            {
                fatal_z("failed to listen on socket: %s", strerror(errno));
            }
        }
        else
        {
            if (connect(peer->socket_fd, (struct sockaddr*)&addr, sizeof(addr)) != 0)
            {
                fatal_z("failed to connect to socket: %s", strerror(errno));
            }

            peer->connection_fd = peer->socket_fd;
            peer->connected     = true;
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Make socket non-blocking (after connection is established for client).
    // =============================================================================================
    // =============================================================================================
    {
        int flags = fcntl(peer->socket_fd, F_GETFL, 0);
        if (flags < 0)
        {
            fatal_z("failed to get socket flags: %s", strerror(errno));
        }
        if (fcntl(peer->socket_fd, F_SETFL, flags | O_NONBLOCK) != 0)
        {
            fatal_z("failed to set socket non-blocking: %s", strerror(errno));
        }
    }

    return peer;
}

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_exit_z: Clean up and destroy a local IPC peer. Closes all file
// descriptors and frees resources.
// =========================================================================================================================================
// =========================================================================================================================================
void local_ipc_exit_z(local_ipc_peer_zh peer)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(peer, "peer is null");
    }

    // =============================================================================================
    // =============================================================================================
    // Close connection file descriptor if connected.
    // =============================================================================================
    // =============================================================================================
    {
        if (peer->connected && peer->connection_fd >= 0 && peer->connection_fd != peer->socket_fd)
        {
            close(peer->connection_fd);
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Close socket file descriptor.
    // =============================================================================================
    // =============================================================================================
    {
        if (peer->socket_fd >= 0)
        {
            close(peer->socket_fd);
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Unlink socket file if server.
    // =============================================================================================
    // =============================================================================================
    {
        if (peer->is_server && peer->socket_path)
        {
            unlink(peer->socket_path);
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Free allocated memory.
    // =============================================================================================
    // =============================================================================================
    {
        if (peer->socket_path)
        {
            free(peer->socket_path);
        }
        free(peer);
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_try_accept_z: Accept an incoming connection (server only). Returns
// true if connection accepted, false if no connection available.
// =========================================================================================================================================
// =========================================================================================================================================
bool local_ipc_try_accept_z(local_ipc_peer_zh peer)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(peer, "peer is null");
        fatal_check_bool_z(peer->is_server, "accept called on client peer");
    }

    // =============================================================================================
    // =============================================================================================
    // Accept incoming connection (non-blocking).
    // =============================================================================================
    // =============================================================================================
    {
        peer->connection_fd = accept(peer->socket_fd, nullptr, nullptr);
        if (peer->connection_fd < 0)
        {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
            {
                return false;
            }
            fatal_z("failed to accept connection: %s", strerror(errno));
        }

        // Make connection socket non-blocking for non-blocking recv
        {
            int flags = fcntl(peer->connection_fd, F_GETFL, 0);
            if (flags < 0)
            {
                fatal_z("failed to get connection socket flags: %s", strerror(errno));
            }
            if (fcntl(peer->connection_fd, F_SETFL, flags | O_NONBLOCK) != 0)
            {
                fatal_z("failed to set connection socket non-blocking: %s", strerror(errno));
            }
        }
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    peer->connected = true;
    return true;
}

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_send_z: Send data through the IPC connection. Fatal on error.
// =========================================================================================================================================
// =========================================================================================================================================
void local_ipc_send_z(local_ipc_peer_zh peer, const uint8_t* data, size_t data_size)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(peer, "peer is null");
        fatal_check_z(data, "data is null");
        fatal_check_bool_z(peer->connected, "peer is not connected");
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    int fd = peer->is_server ? peer->connection_fd : peer->socket_fd;

    // =============================================================================================
    // =============================================================================================
    // Send data in a loop until all bytes are sent.
    // =============================================================================================
    // =============================================================================================
    {
        size_t total_sent = 0;
        while (total_sent < data_size)
        {
            ssize_t sent = send(fd, data + total_sent, data_size - total_sent, 0);
            if (sent < 0)
            {
                if (errno == EAGAIN || errno == EWOULDBLOCK)
                {
                    // Socket buffer is full, wait until it's writable.
                    fd_set write_fds;
                    FD_ZERO(&write_fds);
                    FD_SET(fd, &write_fds);
                    if (select(fd + 1, nullptr, &write_fds, nullptr, nullptr) < 0)
                    {
                        fatal_z("failed to wait for socket to become writable: %s", strerror(errno));
                    }
                    continue;
                }
                fatal_z(
                    "failed to send data: %s, data_size: %zu, total_sent: %zu, "
                    "sent: %zd",
                    strerror(errno),
                    data_size,
                    total_sent,
                    sent
                );
            }
            total_sent += (size_t)sent;
        }
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_try_recv_z: Receive data from the IPC connection (non-blocking).
// Returns true if message received, false if no message available.
// =========================================================================================================================================
// =========================================================================================================================================
bool local_ipc_try_recv_z(local_ipc_peer_zh peer, uint8_t* out_data, size_t* p_out_size, size_t out_capacity)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(peer, "peer is null");
        fatal_check_z(out_data, "out_data is null");
        fatal_check_z(p_out_size, "p_out_size is null");
        fatal_check_bool_z(peer->connected, "peer is not connected");
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    int fd = peer->is_server ? peer->connection_fd : peer->socket_fd;

    // =============================================================================================
    // =============================================================================================
    // Receive data (non-blocking).
    // =============================================================================================
    // =============================================================================================
    {
        ssize_t received = recv(fd, out_data, out_capacity, MSG_DONTWAIT);
        if (received < 0)
        {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
            {
                return false;
            }
            fatal_z("failed to receive data: %s", strerror(errno));
        }
        *p_out_size = (size_t)received;
        return received > 0;
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_send_fds_z: Send file descriptors through the IPC connection using SCM_RIGHTS.
// Fatal on error.
// =========================================================================================================================================
// =========================================================================================================================================
void local_ipc_send_fds_z(local_ipc_peer_zh peer, const int* fds, size_t fd_count)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(peer, "peer is null");
        fatal_check_z(fds, "fds is null");
        fatal_check_bool_z(fd_count > 0, "fd_count must be > 0");
        fatal_check_bool_z(peer->connected, "peer is not connected");
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    int fd = peer->is_server ? peer->connection_fd : peer->socket_fd;

    // =============================================================================================
    // =============================================================================================
    // Prepare message with file descriptors as ancillary data.
    // =============================================================================================
    // =============================================================================================
    {
        // Dummy data byte (required for sendmsg)
        uint8_t dummy = 0;

        struct iovec iov    = {};
        iov.iov_base        = &dummy;
        iov.iov_len         = 1;

        // Calculate control message size
        size_t cmsg_space   = CMSG_SPACE(fd_count * sizeof(int));
        uint8_t* cmsg_buf   = (uint8_t*)fatal_alloc_z(cmsg_space, "failed to allocate cmsg buffer");
        memset(cmsg_buf, 0, cmsg_space);

        struct msghdr msg   = {};
        msg.msg_iov         = &iov;
        msg.msg_iovlen      = 1;
        msg.msg_control     = cmsg_buf;
        msg.msg_controllen  = cmsg_space;

        struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg);
        cmsg->cmsg_level     = SOL_SOCKET;
        cmsg->cmsg_type      = SCM_RIGHTS;
        cmsg->cmsg_len       = CMSG_LEN(fd_count * sizeof(int));
        memcpy(CMSG_DATA(cmsg), fds, fd_count * sizeof(int));

        ssize_t sent = sendmsg(fd, &msg, 0);
        free(cmsg_buf);

        if (sent < 0)
        {
            fatal_z("failed to send file descriptors: %s", strerror(errno));
        }
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// local_ipc_try_recv_fds_z: Receive file descriptors from the IPC connection using SCM_RIGHTS.
// Returns true if file descriptors received, false if no message available.
// =========================================================================================================================================
// =========================================================================================================================================
bool local_ipc_try_recv_fds_z(local_ipc_peer_zh peer, int* out_fds, size_t* p_out_count, size_t max_fds)
{
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(peer, "peer is null");
        fatal_check_z(out_fds, "out_fds is null");
        fatal_check_z(p_out_count, "p_out_count is null");
        fatal_check_bool_z(max_fds > 0, "max_fds must be > 0");
        fatal_check_bool_z(peer->connected, "peer is not connected");
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    int fd = peer->is_server ? peer->connection_fd : peer->socket_fd;

    // =============================================================================================
    // =============================================================================================
    // Prepare to receive message with file descriptors as ancillary data.
    // =============================================================================================
    // =============================================================================================
    {
        uint8_t dummy = 0;

        struct iovec iov    = {};
        iov.iov_base        = &dummy;
        iov.iov_len         = 1;

        size_t cmsg_space   = CMSG_SPACE(max_fds * sizeof(int));
        uint8_t* cmsg_buf   = (uint8_t*)fatal_alloc_z(cmsg_space, "failed to allocate cmsg buffer");
        memset(cmsg_buf, 0, cmsg_space);

        struct msghdr msg   = {};
        msg.msg_iov         = &iov;
        msg.msg_iovlen      = 1;
        msg.msg_control     = cmsg_buf;
        msg.msg_controllen  = cmsg_space;

        ssize_t received = recvmsg(fd, &msg, MSG_DONTWAIT);
        if (received < 0)
        {
            free(cmsg_buf);
            if (errno == EAGAIN || errno == EWOULDBLOCK)
            {
                return false;
            }
            fatal_z("failed to receive file descriptors: %s", strerror(errno));
        }

        if (received == 0)
        {
            free(cmsg_buf);
            *p_out_count = 0;
            return false;
        }

        // Extract file descriptors from ancillary data
        *p_out_count = 0;
        for (struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg))
        {
            if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS)
            {
                size_t num_fds = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(int);
                if (num_fds > max_fds)
                {
                    num_fds = max_fds;
                }
                memcpy(out_fds, CMSG_DATA(cmsg), num_fds * sizeof(int));
                *p_out_count = num_fds;
                break;
            }
        }

        free(cmsg_buf);
        return *p_out_count > 0;
    }
}
