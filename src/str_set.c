#include "zpc/str_set.h"

#include <stdint.h>
#include <string.h>

#include "zpc/fatal.h"

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
constexpr size_t STR_SET_EMPTY_SLOT  = 0U;
constexpr size_t STR_SET_TOMBSTONE   = 1U;
constexpr size_t STR_SET_FIRST_VALID = 2U;
constexpr double STR_SET_LOAD_FACTOR = 0.7;

struct str_set_zt
{
    char** strings;
    size_t* hashes;
    size_t capacity;
    size_t count;
    arena_zh arena;
};

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
static size_t str_set_hash_z(const char* str)
{
    // =============================================================================================
    // =============================================================================================
    // FNV-1a hash implementation.
    // =============================================================================================
    // =============================================================================================
    size_t hash;
    {
        hash = 14695981039346656037ULL;
        while (*str != '\0')
        {
            hash ^= (size_t)(uint8_t)*str;
            hash *= 1099511628211ULL;
            str++;
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Ensure hash is at least STR_SET_FIRST_VALID to distinguish from
    // empty/tombstone.
    // =============================================================================================
    // =============================================================================================
    {
        if (hash < STR_SET_FIRST_VALID)
        {
            hash = STR_SET_FIRST_VALID;
        }
    }

    return hash;
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
static size_t str_set_find_slot_z(str_set_zh set, const char* str, size_t hash)
{
    // =============================================================================================
    // =============================================================================================
    // Linear probing to find the slot.
    // =============================================================================================
    // =============================================================================================
    size_t index;
    {
        index            = hash % set->capacity;
        size_t tombstone = SIZE_MAX;

        for (size_t i = 0U; i < set->capacity; ++i)
        {
            size_t slot_hash = set->hashes[index];

            if (slot_hash == STR_SET_EMPTY_SLOT)
            {
                // Return tombstone slot if we found one, otherwise this empty slot
                return (tombstone != SIZE_MAX) ? tombstone : index;
            }

            if (slot_hash == STR_SET_TOMBSTONE)
            {
                // Remember first tombstone for potential insertion
                if (tombstone == SIZE_MAX)
                {
                    tombstone = index;
                }
            }
            else if (slot_hash == hash && strcmp(set->strings[index], str) == 0)
            {
                // Found existing entry
                return index;
            }

            index = (index + 1U) % set->capacity;
        }
    }

    // Should not reach here if load factor is maintained
    fatal_z("str_set_find_slot: table is full");
    return 0U;
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
static void str_set_grow_z(str_set_zh set)
{
    // =============================================================================================
    // =============================================================================================
    // Save old data.
    // =============================================================================================
    // =============================================================================================
    char** old_strings  = set->strings;
    size_t* old_hashes  = set->hashes;
    size_t old_capacity = set->capacity;

    // =============================================================================================
    // =============================================================================================
    // Calculate new capacity (double the current capacity).
    // =============================================================================================
    // =============================================================================================
    size_t new_capacity;
    {
        fatal_check_bool_z(set->capacity <= SIZE_MAX / 2U, "capacity overflow when doubling");
        new_capacity = set->capacity * 2U;
    }

    // =============================================================================================
    // =============================================================================================
    // Allocate new arrays from arena.
    // =============================================================================================
    // =============================================================================================
    {
        span_zh strings_span = arena_alloc_z(set->arena, sizeof(char*) * new_capacity);
        span_zh hashes_span  = arena_alloc_z(set->arena, sizeof(size_t) * new_capacity);

        set->strings         = (char**)strings_span->data;
        set->hashes          = (size_t*)hashes_span->data;
        set->capacity        = new_capacity;
        set->count           = 0U;

        // Initialize new arrays (arena_alloc_z already zeroes memory)
    }

    // =============================================================================================
    // =============================================================================================
    // Rehash all existing entries into new table.
    // =============================================================================================
    // =============================================================================================
    {
        for (size_t i = 0U; i < old_capacity; ++i)
        {
            if (old_hashes[i] >= STR_SET_FIRST_VALID)
            {
                size_t hash         = old_hashes[i];
                size_t index        = str_set_find_slot_z(set, old_strings[i], hash);

                set->strings[index] = old_strings[i];
                set->hashes[index]  = hash;
                set->count++;
            }
        }
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
str_set_zh str_set_init_z(arena_zh arena, size_t initial_capacity)
{
    // =============================================================================================
    // =============================================================================================
    // Validate inputs.
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(arena, "arena is null");
        fatal_check_bool_z(initial_capacity > 0U, "initial_capacity must be greater than zero");
    }

    // =============================================================================================
    // =============================================================================================
    // Allocate set structure on arena.
    // =============================================================================================
    // =============================================================================================
    str_set_zh set;
    {
        span_zh set_span = arena_alloc_z(arena, sizeof(struct str_set_zt));
        set              = (str_set_zh)set_span->data;
    }

    // =============================================================================================
    // =============================================================================================
    // Allocate hash table arrays from arena.
    // =============================================================================================
    // =============================================================================================
    {
        span_zh strings_span = arena_alloc_z(arena, sizeof(char*) * initial_capacity);
        span_zh hashes_span  = arena_alloc_z(arena, sizeof(size_t) * initial_capacity);

        set->strings         = (char**)strings_span->data;
        set->hashes          = (size_t*)hashes_span->data;
        set->capacity        = initial_capacity;
        set->count           = 0U;
        set->arena           = arena;

        // Arrays are already zeroed by arena_alloc_z
    }

    return set;
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
bool str_set_add_z(str_set_zh set, const char* str)
{
    // =============================================================================================
    // =============================================================================================
    // Validate inputs.
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(set, "set is null");
        fatal_check_z(str, "str is null");
    }

    // =============================================================================================
    // =============================================================================================
    // Check load factor and grow if needed.
    // =============================================================================================
    // =============================================================================================
    {
        double load = (double)(set->count + 1U) / (double)set->capacity;
        if (load > STR_SET_LOAD_FACTOR)
        {
            str_set_grow_z(set);
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Find slot and check if string already exists.
    // =============================================================================================
    // =============================================================================================
    size_t hash  = str_set_hash_z(str);
    size_t index = str_set_find_slot_z(set, str, hash);
    {
        if (set->hashes[index] >= STR_SET_FIRST_VALID)
        {
            // String already exists
            return false;
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Copy string and insert into set.
    // =============================================================================================
    // =============================================================================================
    {
        size_t len       = strlen(str);
        span_zh str_span = arena_alloc_z(set->arena, len + 1U);
        char* str_copy   = (char*)str_span->data;
        memcpy(str_copy, str, len + 1U);

        set->strings[index] = str_copy;
        set->hashes[index]  = hash;
        set->count++;
    }

    return true;
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
bool str_set_contains_z(str_set_zh set, const char* str)
{
    // =============================================================================================
    // =============================================================================================
    // Validate inputs.
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(set, "set is null");
        fatal_check_z(str, "str is null");
    }

    // =============================================================================================
    // =============================================================================================
    // Find slot and check if it contains a valid entry.
    // =============================================================================================
    // =============================================================================================
    {
        size_t hash  = str_set_hash_z(str);
        size_t index = hash % set->capacity;

        for (size_t i = 0U; i < set->capacity; ++i)
        {
            size_t slot_hash = set->hashes[index];

            if (slot_hash == STR_SET_EMPTY_SLOT)
            {
                return false;
            }

            if (slot_hash >= STR_SET_FIRST_VALID && slot_hash == hash && strcmp(set->strings[index], str) == 0)
            {
                return true;
            }

            index = (index + 1U) % set->capacity;
        }
    }

    return false;
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
size_t str_set_count_z(str_set_zh set)
{
    fatal_check_z(set, "set is null");
    return set->count;
}

// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
// =========================================================================================================================================
void str_set_clear_z(str_set_zh set)
{
    // =============================================================================================
    // =============================================================================================
    // Validate inputs.
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(set, "set is null");
    }

    // =============================================================================================
    // =============================================================================================
    // Reset all hash slots to empty and clear count.
    // =============================================================================================
    // =============================================================================================
    {
        memset(set->hashes, 0, sizeof(size_t) * set->capacity);
        set->count = 0U;
    }
}
