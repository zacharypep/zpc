#define _GNU_SOURCE
#include "zpc/math.h"
#include "zpc/fatal.h"
#include <math.h>
#include <stdio.h>
#include <string.h>

// =========================================================================================================================================
// =========================================================================================================================================
// vec2 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_add_z: Adds two vec2 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_add_z(vec2_zt a, vec2_zt b)
{
    return (vec2_zt){a.x + b.x, a.y + b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_sub_z: Subtracts vec2 b from vec2 a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_sub_z(vec2_zt a, vec2_zt b)
{
    return (vec2_zt){a.x - b.x, a.y - b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_mul_z: Multiplies two vec2 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_mul_z(vec2_zt a, vec2_zt b)
{
    return (vec2_zt){a.x * b.x, a.y * b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_div_z: Divides vec2 a by vec2 b component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_div_z(vec2_zt a, vec2_zt b)
{
    return (vec2_zt){a.x / b.x, a.y / b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_mul_scalar_z: Multiplies vec2 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_mul_scalar_z(vec2_zt v, float s)
{
    return (vec2_zt){v.x * s, v.y * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_div_scalar_z: Divides vec2 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_div_scalar_z(vec2_zt v, float s)
{
    return (vec2_zt){v.x / s, v.y / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_neg_z: Negates vec2 component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_neg_z(vec2_zt v)
{
    return (vec2_zt){-v.x, -v.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_eq_z: Checks if two vec2 vectors are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool vec2_eq_z(vec2_zt a, vec2_zt b)
{
    return a.x == b.x && a.y == b.y;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_dot_z: Computes dot product of two vec2 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
float vec2_dot_z(vec2_zt a, vec2_zt b)
{
    return a.x * b.x + a.y * b.y;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_cross_z: Computes 2D cross product (scalar result).
// =========================================================================================================================================
// =========================================================================================================================================
float vec2_cross_z(vec2_zt a, vec2_zt b)
{
    return a.x * b.y - a.y * b.x;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_length2_z: Computes squared length of vec2.
// =========================================================================================================================================
// =========================================================================================================================================
float vec2_length2_z(vec2_zt v)
{
    return v.x * v.x + v.y * v.y;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_length_z: Computes length of vec2.
// =========================================================================================================================================
// =========================================================================================================================================
float vec2_length_z(vec2_zt v)
{
    return sqrtf(vec2_length2_z(v));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_normalize_z: Normalizes vec2 to unit length.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_normalize_z(vec2_zt v)
{
    float len = vec2_length_z(v);
    if (len == 0.0f)
    {
        return (vec2_zt){0.0f, 0.0f};
    }
    return vec2_div_scalar_z(v, len);
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_distance_z: Computes distance between two vec2 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
float vec2_distance_z(vec2_zt a, vec2_zt b)
{
    return vec2_length_z(vec2_sub_z(a, b));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_lerp_z: Linear interpolation between two vec2 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_lerp_z(vec2_zt a, vec2_zt b, float t)
{
    return vec2_add_z(a, vec2_mul_scalar_z(vec2_sub_z(b, a), t));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_min_z: Component-wise minimum of two vec2 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_min_z(vec2_zt a, vec2_zt b)
{
    return (vec2_zt){a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_max_z: Component-wise maximum of two vec2 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_max_z(vec2_zt a, vec2_zt b)
{
    return (vec2_zt){a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_clamp_z: Clamps vec2 components between lo and hi.
// =========================================================================================================================================
// =========================================================================================================================================
vec2_zt vec2_clamp_z(vec2_zt v, vec2_zt lo, vec2_zt hi)
{
    return vec2_max_z(lo, vec2_min_z(hi, v));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_add_z: Adds two vec3 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_add_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.x + b.x, a.y + b.y, a.z + b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_sub_z: Subtracts vec3 b from vec3 a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_sub_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.x - b.x, a.y - b.y, a.z - b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_mul_z: Multiplies two vec3 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_mul_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.x * b.x, a.y * b.y, a.z * b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_div_z: Divides vec3 a by vec3 b component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_div_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.x / b.x, a.y / b.y, a.z / b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_mul_scalar_z: Multiplies vec3 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_mul_scalar_z(vec3_zt v, float s)
{
    return (vec3_zt){v.x * s, v.y * s, v.z * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_div_scalar_z: Divides vec3 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_div_scalar_z(vec3_zt v, float s)
{
    return (vec3_zt){v.x / s, v.y / s, v.z / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_neg_z: Negates vec3 component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_neg_z(vec3_zt v)
{
    return (vec3_zt){-v.x, -v.y, -v.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_eq_z: Checks if two vec3 vectors are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool vec3_eq_z(vec3_zt a, vec3_zt b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_dot_z: Computes dot product of two vec3 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
float vec3_dot_z(vec3_zt a, vec3_zt b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_cross_z: Computes cross product of two vec3 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_cross_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_length2_z: Computes squared length of vec3.
// =========================================================================================================================================
// =========================================================================================================================================
float vec3_length2_z(vec3_zt v)
{
    return v.x * v.x + v.y * v.y + v.z * v.z;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_length_z: Computes length of vec3.
// =========================================================================================================================================
// =========================================================================================================================================
float vec3_length_z(vec3_zt v)
{
    return sqrtf(vec3_length2_z(v));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_normalize_z: Normalizes vec3 to unit length.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_normalize_z(vec3_zt v)
{
    float len = vec3_length_z(v);
    if (len == 0.0f)
    {
        return (vec3_zt){0.0f, 0.0f, 0.0f};
    }
    return vec3_div_scalar_z(v, len);
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_distance_z: Computes distance between two vec3 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
float vec3_distance_z(vec3_zt a, vec3_zt b)
{
    return vec3_length_z(vec3_sub_z(a, b));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_lerp_z: Linear interpolation between two vec3 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_lerp_z(vec3_zt a, vec3_zt b, float t)
{
    return vec3_add_z(a, vec3_mul_scalar_z(vec3_sub_z(b, a), t));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_min_z: Component-wise minimum of two vec3 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_min_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y, a.z < b.z ? a.z : b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_max_z: Component-wise maximum of two vec3 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_max_z(vec3_zt a, vec3_zt b)
{
    return (vec3_zt){a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y, a.z > b.z ? a.z : b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_clamp_z: Clamps vec3 components between lo and hi.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt vec3_clamp_z(vec3_zt v, vec3_zt lo, vec3_zt hi)
{
    return vec3_max_z(lo, vec3_min_z(hi, v));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_add_z: Adds two vec4 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_add_z(vec4_zt a, vec4_zt b)
{
    return (vec4_zt){a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_sub_z: Subtracts vec4 b from vec4 a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_sub_z(vec4_zt a, vec4_zt b)
{
    return (vec4_zt){a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_mul_z: Multiplies two vec4 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_mul_z(vec4_zt a, vec4_zt b)
{
    return (vec4_zt){a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_div_z: Divides vec4 a by vec4 b component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_div_z(vec4_zt a, vec4_zt b)
{
    return (vec4_zt){a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_mul_scalar_z: Multiplies vec4 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_mul_scalar_z(vec4_zt v, float s)
{
    return (vec4_zt){v.x * s, v.y * s, v.z * s, v.w * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_div_scalar_z: Divides vec4 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_div_scalar_z(vec4_zt v, float s)
{
    return (vec4_zt){v.x / s, v.y / s, v.z / s, v.w / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_neg_z: Negates vec4 component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_neg_z(vec4_zt v)
{
    return (vec4_zt){-v.x, -v.y, -v.z, -v.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_eq_z: Checks if two vec4 vectors are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool vec4_eq_z(vec4_zt a, vec4_zt b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_dot_z: Computes dot product of two vec4 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
float vec4_dot_z(vec4_zt a, vec4_zt b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_length2_z: Computes squared length of vec4.
// =========================================================================================================================================
// =========================================================================================================================================
float vec4_length2_z(vec4_zt v)
{
    return v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_length_z: Computes length of vec4.
// =========================================================================================================================================
// =========================================================================================================================================
float vec4_length_z(vec4_zt v)
{
    return sqrtf(vec4_length2_z(v));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_normalize_z: Normalizes vec4 to unit length.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_normalize_z(vec4_zt v)
{
    float len = vec4_length_z(v);
    if (len == 0.0f)
    {
        return (vec4_zt){0.0f, 0.0f, 0.0f, 0.0f};
    }
    return vec4_div_scalar_z(v, len);
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_distance_z: Computes distance between two vec4 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
float vec4_distance_z(vec4_zt a, vec4_zt b)
{
    return vec4_length_z(vec4_sub_z(a, b));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_lerp_z: Linear interpolation between two vec4 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_lerp_z(vec4_zt a, vec4_zt b, float t)
{
    return vec4_add_z(a, vec4_mul_scalar_z(vec4_sub_z(b, a), t));
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_min_z: Component-wise minimum of two vec4 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_min_z(vec4_zt a, vec4_zt b)
{
    return (vec4_zt){a.x < b.x ? a.x : b.x, a.y < b.y ? a.y : b.y, a.z < b.z ? a.z : b.z, a.w < b.w ? a.w : b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_max_z: Component-wise maximum of two vec4 vectors.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_max_z(vec4_zt a, vec4_zt b)
{
    return (vec4_zt){a.x > b.x ? a.x : b.x, a.y > b.y ? a.y : b.y, a.z > b.z ? a.z : b.z, a.w > b.w ? a.w : b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_clamp_z: Clamps vec4 components between lo and hi.
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt vec4_clamp_z(vec4_zt v, vec4_zt lo, vec4_zt hi)
{
    return vec4_max_z(lo, vec4_min_z(hi, v));
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_add_z: Adds two ivec2 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_add_z(ivec2_zt a, ivec2_zt b)
{
    return (ivec2_zt){a.x + b.x, a.y + b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_sub_z: Subtracts ivec2 b from ivec2 a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_sub_z(ivec2_zt a, ivec2_zt b)
{
    return (ivec2_zt){a.x - b.x, a.y - b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_mul_z: Multiplies two ivec2 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_mul_z(ivec2_zt a, ivec2_zt b)
{
    return (ivec2_zt){a.x * b.x, a.y * b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_div_z: Divides ivec2 a by ivec2 b component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_div_z(ivec2_zt a, ivec2_zt b)
{
    return (ivec2_zt){a.x / b.x, a.y / b.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_mul_scalar_z: Multiplies ivec2 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_mul_scalar_z(ivec2_zt v, int s)
{
    return (ivec2_zt){v.x * s, v.y * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_div_scalar_z: Divides ivec2 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_div_scalar_z(ivec2_zt v, int s)
{
    return (ivec2_zt){v.x / s, v.y / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_neg_z: Negates ivec2 component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt ivec2_neg_z(ivec2_zt v)
{
    return (ivec2_zt){-v.x, -v.y};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_eq_z: Checks if two ivec2 vectors are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool ivec2_eq_z(ivec2_zt a, ivec2_zt b)
{
    return a.x == b.x && a.y == b.y;
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_add_z: Adds two ivec3 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_add_z(ivec3_zt a, ivec3_zt b)
{
    return (ivec3_zt){a.x + b.x, a.y + b.y, a.z + b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_sub_z: Subtracts ivec3 b from ivec3 a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_sub_z(ivec3_zt a, ivec3_zt b)
{
    return (ivec3_zt){a.x - b.x, a.y - b.y, a.z - b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_mul_z: Multiplies two ivec3 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_mul_z(ivec3_zt a, ivec3_zt b)
{
    return (ivec3_zt){a.x * b.x, a.y * b.y, a.z * b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_div_z: Divides ivec3 a by ivec3 b component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_div_z(ivec3_zt a, ivec3_zt b)
{
    return (ivec3_zt){a.x / b.x, a.y / b.y, a.z / b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_mul_scalar_z: Multiplies ivec3 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_mul_scalar_z(ivec3_zt v, int s)
{
    return (ivec3_zt){v.x * s, v.y * s, v.z * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_div_scalar_z: Divides ivec3 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_div_scalar_z(ivec3_zt v, int s)
{
    return (ivec3_zt){v.x / s, v.y / s, v.z / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_neg_z: Negates ivec3 component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec3_zt ivec3_neg_z(ivec3_zt v)
{
    return (ivec3_zt){-v.x, -v.y, -v.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_eq_z: Checks if two ivec3 vectors are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool ivec3_eq_z(ivec3_zt a, ivec3_zt b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z;
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_add_z: Adds two ivec4 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_add_z(ivec4_zt a, ivec4_zt b)
{
    return (ivec4_zt){a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_sub_z: Subtracts ivec4 b from ivec4 a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_sub_z(ivec4_zt a, ivec4_zt b)
{
    return (ivec4_zt){a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_mul_z: Multiplies two ivec4 vectors component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_mul_z(ivec4_zt a, ivec4_zt b)
{
    return (ivec4_zt){a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_div_z: Divides ivec4 a by ivec4 b component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_div_z(ivec4_zt a, ivec4_zt b)
{
    return (ivec4_zt){a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_mul_scalar_z: Multiplies ivec4 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_mul_scalar_z(ivec4_zt v, int s)
{
    return (ivec4_zt){v.x * s, v.y * s, v.z * s, v.w * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_div_scalar_z: Divides ivec4 by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_div_scalar_z(ivec4_zt v, int s)
{
    return (ivec4_zt){v.x / s, v.y / s, v.z / s, v.w / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_neg_z: Negates ivec4 component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
ivec4_zt ivec4_neg_z(ivec4_zt v)
{
    return (ivec4_zt){-v.x, -v.y, -v.z, -v.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_eq_z: Checks if two ivec4 vectors are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool ivec4_eq_z(ivec4_zt a, ivec4_zt b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// quat_add_z: Adds two quaternions component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_add_z(quat_zt a, quat_zt b)
{
    return (quat_zt){a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_sub_z: Subtracts quaternion b from quaternion a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_sub_z(quat_zt a, quat_zt b)
{
    return (quat_zt){a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_mul_z: Multiplies two quaternions (quaternion multiplication).
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_mul_z(quat_zt a, quat_zt b)
{
    return (quat_zt){a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y, a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w, a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_mul_scalar_z: Multiplies quaternion by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_mul_scalar_z(quat_zt q, float s)
{
    return (quat_zt){q.x * s, q.y * s, q.z * s, q.w * s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_div_scalar_z: Divides quaternion by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_div_scalar_z(quat_zt q, float s)
{
    return (quat_zt){q.x / s, q.y / s, q.z / s, q.w / s};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_neg_z: Negates quaternion component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_neg_z(quat_zt q)
{
    return (quat_zt){-q.x, -q.y, -q.z, -q.w};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_eq_z: Checks if two quaternions are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool quat_eq_z(quat_zt a, quat_zt b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_normalize_z: Normalizes quaternion to unit length.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_normalize_z(quat_zt q)
{
    float len2 = q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w;
    if (len2 == 0.0f)
    {
        return (quat_zt){0.0f, 0.0f, 0.0f, 1.0f};
    }
    float len = sqrtf(len2);
    return quat_div_scalar_z(q, len);
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_rotation_to_face_z: Creates quaternion rotation to face given direction.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_rotation_to_face_z(vec3_zt dir_to_face)
{
    vec3_zt forward  = MATH_FORWARD;
    vec3_zt dir_norm = vec3_normalize_z(dir_to_face);

    float dot        = vec3_dot_z(forward, dir_norm);
    if (dot > 0.9999f)
    {
        return (quat_zt){0.0f, 0.0f, 0.0f, 1.0f};
    }
    if (dot < -0.9999f)
    {
        vec3_zt axis = vec3_cross_z(forward, MATH_RIGHT);
        if (vec3_length2_z(axis) < 0.0001f)
        {
            axis = vec3_cross_z(forward, MATH_UP);
        }
        axis        = vec3_normalize_z(axis);
        float angle = 3.14159265358979323846f;
        float s     = sinf(angle * 0.5f);
        return (quat_zt){axis.x * s, axis.y * s, axis.z * s, cosf(angle * 0.5f)};
    }

    vec3_zt axis = vec3_cross_z(forward, dir_norm);
    axis         = vec3_normalize_z(axis);
    float angle  = acosf(dot);
    float s      = sinf(angle * 0.5f);
    return (quat_zt){axis.x * s, axis.y * s, axis.z * s, cosf(angle * 0.5f)};
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_slerp_z: Spherical linear interpolation between two quaternions.
// =========================================================================================================================================
// =========================================================================================================================================
quat_zt quat_slerp_z(quat_zt q0, quat_zt q1, float f)
{
    float dot = q0.x * q1.x + q0.y * q1.y + q0.z * q1.z + q0.w * q1.w;
    if (dot < 0.0f)
    {
        q1  = quat_neg_z(q1);
        dot = -dot;
    }

    if (dot > 0.9995f)
    {
        return quat_normalize_z(quat_add_z(q0, quat_mul_scalar_z(quat_sub_z(q1, q0), f)));
    }

    float theta     = acosf(dot);
    float sin_theta = sinf(theta);
    float w0        = sinf((1.0f - f) * theta) / sin_theta;
    float w1        = sinf(f * theta) / sin_theta;

    quat_zt result  = quat_add_z(quat_mul_scalar_z(q0, w0), quat_mul_scalar_z(q1, w1));
    return quat_normalize_z(result);
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_identity_z: Creates 3x3 identity matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_identity_z(void)
{
    mat3_zt m = {0};
    m.f[0][0] = 1.0f;
    m.f[1][1] = 1.0f;
    m.f[2][2] = 1.0f;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_from_rows_z: Creates 3x3 matrix from three row vectors.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_from_rows_z(vec3_zt r0, vec3_zt r1, vec3_zt r2)
{
    mat3_zt m;
    m.f[0][0] = r0.x;
    m.f[0][1] = r0.y;
    m.f[0][2] = r0.z;
    m.f[1][0] = r1.x;
    m.f[1][1] = r1.y;
    m.f[1][2] = r1.z;
    m.f[2][0] = r2.x;
    m.f[2][1] = r2.y;
    m.f[2][2] = r2.z;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_mul_z: Multiplies two 3x3 matrices (row-major: A * B).
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_mul_z(mat3_zt a, mat3_zt b)
{
    mat3_zt result = {0};
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            for (int k = 0; k < 3; k++)
            {
                result.f[i][j] += a.f[i][k] * b.f[k][j];
            }
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_mul_vec3_z: Multiplies row vector by 3x3 matrix (row-major: v * M).
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt mat3_mul_vec3_z(vec3_zt v, mat3_zt m)
{
    return (vec3_zt){v.x * m.f[0][0] + v.y * m.f[1][0] + v.z * m.f[2][0], v.x * m.f[0][1] + v.y * m.f[1][1] + v.z * m.f[2][1], v.x * m.f[0][2] + v.y * m.f[1][2] + v.z * m.f[2][2]};
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_add_z: Adds two 3x3 matrices component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_add_z(mat3_zt a, mat3_zt b)
{
    mat3_zt result;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            result.f[i][j] = a.f[i][j] + b.f[i][j];
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_sub_z: Subtracts 3x3 matrix b from 3x3 matrix a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_sub_z(mat3_zt a, mat3_zt b)
{
    mat3_zt result;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            result.f[i][j] = a.f[i][j] - b.f[i][j];
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_mul_scalar_z: Multiplies 3x3 matrix by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_mul_scalar_z(mat3_zt m, float s)
{
    mat3_zt result;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            result.f[i][j] = m.f[i][j] * s;
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_div_scalar_z: Divides 3x3 matrix by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_div_scalar_z(mat3_zt m, float s)
{
    mat3_zt result;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            result.f[i][j] = m.f[i][j] / s;
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_eq_z: Checks if two 3x3 matrices are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool mat3_eq_z(mat3_zt a, mat3_zt b)
{
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            if (a.f[i][j] != b.f[i][j])
            {
                return false;
            }
        }
    }
    return true;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_transpose_z: Transposes 3x3 matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_transpose_z(mat3_zt m)
{
    mat3_zt result;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            result.f[i][j] = m.f[j][i];
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_inverse_z: Computes inverse of 3x3 matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat3_inverse_z(mat3_zt m)
{
    float a = m.f[0][0], b = m.f[0][1], c = m.f[0][2];
    float d = m.f[1][0], e = m.f[1][1], f = m.f[1][2];
    float g = m.f[2][0], h = m.f[2][1], i = m.f[2][2];

    float det = a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);
    if (det == 0.0f)
    {
        return mat3_identity_z();
    }

    float inv_det = 1.0f / det;
    mat3_zt inv;
    inv.f[0][0] = inv_det * (e * i - f * h);
    inv.f[0][1] = inv_det * -(b * i - c * h);
    inv.f[0][2] = inv_det * (b * f - c * e);
    inv.f[1][0] = inv_det * -(d * i - f * g);
    inv.f[1][1] = inv_det * (a * i - c * g);
    inv.f[1][2] = inv_det * -(a * f - c * d);
    inv.f[2][0] = inv_det * (d * h - e * g);
    inv.f[2][1] = inv_det * -(a * h - b * g);
    inv.f[2][2] = inv_det * (a * e - b * d);

    return inv;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4 operations
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_identity_z: Creates 4x4 identity matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_identity_z(void)
{
    mat4_zt m = {0};
    m.f[0][0] = 1.0f;
    m.f[1][1] = 1.0f;
    m.f[2][2] = 1.0f;
    m.f[3][3] = 1.0f;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_from_rows_z: Creates 4x4 matrix from four row vectors.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_from_rows_z(vec4_zt r0, vec4_zt r1, vec4_zt r2, vec4_zt r3)
{
    mat4_zt m;
    m.f[0][0] = r0.x;
    m.f[0][1] = r0.y;
    m.f[0][2] = r0.z;
    m.f[0][3] = r0.w;
    m.f[1][0] = r1.x;
    m.f[1][1] = r1.y;
    m.f[1][2] = r1.z;
    m.f[1][3] = r1.w;
    m.f[2][0] = r2.x;
    m.f[2][1] = r2.y;
    m.f[2][2] = r2.z;
    m.f[2][3] = r2.w;
    m.f[3][0] = r3.x;
    m.f[3][1] = r3.y;
    m.f[3][2] = r3.z;
    m.f[3][3] = r3.w;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_mul_z: Multiplies two 4x4 matrices (row-major: A * B).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_mul_z(mat4_zt a, mat4_zt b)
{
    mat4_zt result = {0};
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            for (int k = 0; k < 4; k++)
            {
                result.f[i][j] += a.f[i][k] * b.f[k][j];
            }
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_mul_vec4_z: Multiplies row vector by 4x4 matrix (row-major: v * M).
// =========================================================================================================================================
// =========================================================================================================================================
vec4_zt mat4_mul_vec4_z(vec4_zt v, mat4_zt m)
{
    return (
        vec4_zt
    ){v.x * m.f[0][0] + v.y * m.f[1][0] + v.z * m.f[2][0] + v.w * m.f[3][0], v.x * m.f[0][1] + v.y * m.f[1][1] + v.z * m.f[2][1] + v.w * m.f[3][1], v.x * m.f[0][2] + v.y * m.f[1][2] + v.z * m.f[2][2] + v.w * m.f[3][2], v.x * m.f[0][3] + v.y * m.f[1][3] + v.z * m.f[2][3] + v.w * m.f[3][3]};
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_add_z: Adds two 4x4 matrices component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_add_z(mat4_zt a, mat4_zt b)
{
    mat4_zt result;
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            result.f[i][j] = a.f[i][j] + b.f[i][j];
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_sub_z: Subtracts 4x4 matrix b from 4x4 matrix a component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_sub_z(mat4_zt a, mat4_zt b)
{
    mat4_zt result;
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            result.f[i][j] = a.f[i][j] - b.f[i][j];
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_mul_scalar_z: Multiplies 4x4 matrix by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_mul_scalar_z(mat4_zt m, float s)
{
    mat4_zt result;
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            result.f[i][j] = m.f[i][j] * s;
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_div_scalar_z: Divides 4x4 matrix by scalar.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_div_scalar_z(mat4_zt m, float s)
{
    mat4_zt result;
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            result.f[i][j] = m.f[i][j] / s;
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_eq_z: Checks if two 4x4 matrices are equal component-wise.
// =========================================================================================================================================
// =========================================================================================================================================
bool mat4_eq_z(mat4_zt a, mat4_zt b)
{
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            if (a.f[i][j] != b.f[i][j])
            {
                return false;
            }
        }
    }
    return true;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_transpose_z: Transposes 4x4 matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_transpose_z(mat4_zt m)
{
    mat4_zt result;
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            result.f[i][j] = m.f[j][i];
        }
    }
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_determinant_z: Computes determinant of 4x4 matrix.
// =========================================================================================================================================
// =========================================================================================================================================
float mat4_determinant_z(mat4_zt m)
{
    float a = m.f[0][0], b = m.f[0][1], c = m.f[0][2], d = m.f[0][3];
    float e = m.f[1][0], f = m.f[1][1], g = m.f[1][2], h = m.f[1][3];
    float i = m.f[2][0], j = m.f[2][1], k = m.f[2][2], l = m.f[2][3];
    float mm = m.f[3][0], n = m.f[3][1], o = m.f[3][2], p = m.f[3][3];

    float det = a * (f * (k * p - l * o) - g * (j * p - l * n) + h * (j * o - k * n)) - b * (e * (k * p - l * o) - g * (i * p - l * mm) + h * (i * o - k * mm)) + c * (e * (j * p - l * n) - f * (i * p - l * mm) + h * (i * n - j * mm))
              - d * (e * (j * o - k * n) - f * (i * o - k * mm) + g * (i * n - j * mm));
    return det;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_inverse_z: Computes inverse of 4x4 matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_inverse_z(mat4_zt m)
{
    float det = mat4_determinant_z(m);
    if (det == 0.0f)
    {
        return mat4_identity_z();
    }

    float inv_det = 1.0f / det;
    mat4_zt result;

    float a = m.f[0][0], b = m.f[0][1], c = m.f[0][2], d = m.f[0][3];
    float e = m.f[1][0], f = m.f[1][1], g = m.f[1][2], h = m.f[1][3];
    float i = m.f[2][0], j = m.f[2][1], k = m.f[2][2], l = m.f[2][3];
    float mm = m.f[3][0], n = m.f[3][1], o = m.f[3][2], p = m.f[3][3];

    result.f[0][0] = inv_det * (f * (k * p - l * o) - g * (j * p - l * n) + h * (j * o - k * n));
    result.f[0][1] = inv_det * -(b * (k * p - l * o) - c * (j * p - l * n) + d * (j * o - k * n));
    result.f[0][2] = inv_det * (b * (g * p - h * o) - c * (f * p - h * n) + d * (f * o - g * n));
    result.f[0][3] = inv_det * -(b * (g * l - h * k) - c * (f * l - h * j) + d * (f * k - g * j));

    result.f[1][0] = inv_det * -(e * (k * p - l * o) - g * (i * p - l * mm) + h * (i * o - k * mm));
    result.f[1][1] = inv_det * (a * (k * p - l * o) - c * (i * p - l * mm) + d * (i * o - k * mm));
    result.f[1][2] = inv_det * -(a * (g * p - h * o) - c * (e * p - h * mm) + d * (e * o - g * mm));
    result.f[1][3] = inv_det * (a * (g * l - h * k) - c * (e * l - h * i) + d * (e * k - g * i));

    result.f[2][0] = inv_det * (e * (j * p - l * n) - f * (i * p - l * mm) + h * (i * n - j * mm));
    result.f[2][1] = inv_det * -(a * (j * p - l * n) - b * (i * p - l * mm) + d * (i * n - j * mm));
    result.f[2][2] = inv_det * (a * (f * p - h * n) - b * (e * p - h * mm) + d * (e * n - f * mm));
    result.f[2][3] = inv_det * -(a * (f * l - h * j) - b * (e * l - h * i) + d * (e * j - f * i));

    result.f[3][0] = inv_det * -(e * (j * o - k * n) - f * (i * o - k * mm) + g * (i * n - j * mm));
    result.f[3][1] = inv_det * (a * (j * o - k * n) - b * (i * o - k * mm) + c * (i * n - j * mm));
    result.f[3][2] = inv_det * -(a * (f * o - g * n) - b * (e * o - g * mm) + c * (e * n - f * mm));
    result.f[3][3] = inv_det * (a * (f * k - g * j) - b * (e * k - g * i) + c * (e * j - f * i));

    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// Matrix builders
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_translate_z: Creates 4x4 translation matrix (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_translate_z(vec3_zt t)
{
    mat4_zt m = mat4_identity_z();
    m.f[3][0] = t.x;
    m.f[3][1] = t.y;
    m.f[3][2] = t.z;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_scale_z: Creates 4x4 scale matrix (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_scale_z(vec3_zt s)
{
    mat4_zt m = {0};
    m.f[0][0] = s.x;
    m.f[1][1] = s.y;
    m.f[2][2] = s.z;
    m.f[3][3] = 1.0f;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_rotate_x_z: Creates 4x4 rotation matrix around X axis (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_rotate_x_z(float radians)
{
    float c   = cosf(radians);
    float s   = sinf(radians);
    mat4_zt m = mat4_identity_z();
    m.f[1][1] = c;
    m.f[1][2] = s;
    m.f[2][1] = -s;
    m.f[2][2] = c;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_rotate_y_z: Creates 4x4 rotation matrix around Y axis (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_rotate_y_z(float radians)
{
    float c   = cosf(radians);
    float s   = sinf(radians);
    mat4_zt m = mat4_identity_z();
    m.f[0][0] = c;
    m.f[0][2] = -s;
    m.f[2][0] = s;
    m.f[2][2] = c;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_rotate_z_z: Creates 4x4 rotation matrix around Z axis (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_rotate_z_z(float radians)
{
    float c   = cosf(radians);
    float s   = sinf(radians);
    mat4_zt m = mat4_identity_z();
    m.f[0][0] = c;
    m.f[0][1] = s;
    m.f[1][0] = -s;
    m.f[1][1] = c;
    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_rotate_axis_angle_z: Creates 4x4 rotation matrix around arbitrary axis
// (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_rotate_axis_angle_z(vec3_zt axis, float radians)
{
    vec3_zt a = vec3_normalize_z(axis);
    float c   = cosf(radians);
    float s   = sinf(radians);
    float omc = 1.0f - c;

    mat4_zt m;
    m.f[0][0] = c + a.x * a.x * omc;
    m.f[0][1] = a.x * a.y * omc + a.z * s;
    m.f[0][2] = a.x * a.z * omc - a.y * s;
    m.f[0][3] = 0.0f;

    m.f[1][0] = a.x * a.y * omc - a.z * s;
    m.f[1][1] = c + a.y * a.y * omc;
    m.f[1][2] = a.y * a.z * omc + a.x * s;
    m.f[1][3] = 0.0f;

    m.f[2][0] = a.x * a.z * omc + a.y * s;
    m.f[2][1] = a.y * a.z * omc - a.x * s;
    m.f[2][2] = c + a.z * a.z * omc;
    m.f[2][3] = 0.0f;

    m.f[3][0] = 0.0f;
    m.f[3][1] = 0.0f;
    m.f[3][2] = 0.0f;
    m.f[3][3] = 1.0f;

    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_look_at_z: Creates 4x4 look-at view matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_look_at_z(vec3_zt eye, vec3_zt center, vec3_zt up)
{
    mat4_zt m;

    vec3_zt f = vec3_normalize_z(vec3_sub_z(center, eye));
    vec3_zt s = vec3_normalize_z(vec3_cross_z(f, up));
    vec3_zt u = vec3_cross_z(s, f);

    m.f[0][0] = s.x;
    m.f[0][1] = u.x;
    m.f[0][2] = -f.x;
    m.f[0][3] = 0.0f;

    m.f[1][0] = s.y;
    m.f[1][1] = u.y;
    m.f[1][2] = -f.y;
    m.f[1][3] = 0.0f;

    m.f[2][0] = s.z;
    m.f[2][1] = u.z;
    m.f[2][2] = -f.z;
    m.f[2][3] = 0.0f;

    m.f[3][0] = -vec3_dot_z(s, eye);
    m.f[3][1] = -vec3_dot_z(u, eye);
    m.f[3][2] = vec3_dot_z(f, eye);
    m.f[3][3] = 1.0f;

    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_perspective_z: Creates 4x4 perspective projection matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_perspective_z(float fovy_radians, float aspect, float near, float far)
{
    mat4_zt m           = {0};

    float tan_half_fovy = tanf(fovy_radians * 0.5f);
    float y_scale       = 1.0f / tan_half_fovy;
    float x_scale       = y_scale / aspect;

    m.f[0][0]           = x_scale;
    m.f[1][1]           = y_scale;

    m.f[2][2]           = far / (near - far);
    m.f[2][3]           = -1.0f;
    m.f[3][2]           = (near * far) / (near - far);
    m.f[3][3]           = 0.0f;

    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_ortho_z: Creates 4x4 orthographic projection matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_ortho_z(float left, float right, float bottom, float top, float z_near, float z_far)
{
    mat4_zt m = {0};

    float rml = right - left;
    float tmb = top - bottom;
    float fmn = z_near - z_far;

    m.f[0][0] = 2.0f / rml;
    m.f[1][1] = 2.0f / tmb;
    m.f[2][2] = 1.0f / fmn;

    m.f[3][0] = -(right + left) / rml;
    m.f[3][1] = -(top + bottom) / tmb;
    m.f[3][2] = z_near / fmn;

    m.f[3][3] = 1.0f;

    return m;
}

// =========================================================================================================================================
// =========================================================================================================================================
// Transform helpers
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_get_transform_z: Creates 4x4 transform matrix from translation, rotation
// (quat), and scale (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_get_transform_z(vec3_zt translate, quat_zt rot, vec3_zt sca)
{
    mat4_zt t = mat4_translate_z(translate);
    mat4_zt s = mat4_scale_z(sca);

    quat_zt r = quat_normalize_z(rot);
    float x = r.x, y = r.y, z = r.z, w = r.w;

    mat4_zt rot_mat;
    rot_mat.f[0][0] = 1.0f - 2.0f * (y * y + z * z);
    rot_mat.f[0][1] = 2.0f * (x * y + z * w);
    rot_mat.f[0][2] = 2.0f * (x * z - y * w);
    rot_mat.f[0][3] = 0.0f;

    rot_mat.f[1][0] = 2.0f * (x * y - z * w);
    rot_mat.f[1][1] = 1.0f - 2.0f * (x * x + z * z);
    rot_mat.f[1][2] = 2.0f * (y * z + x * w);
    rot_mat.f[1][3] = 0.0f;

    rot_mat.f[2][0] = 2.0f * (x * z + y * w);
    rot_mat.f[2][1] = 2.0f * (y * z - x * w);
    rot_mat.f[2][2] = 1.0f - 2.0f * (x * x + y * y);
    rot_mat.f[2][3] = 0.0f;

    rot_mat.f[3][0] = 0.0f;
    rot_mat.f[3][1] = 0.0f;
    rot_mat.f[3][2] = 0.0f;
    rot_mat.f[3][3] = 1.0f;

    // Transform composition: S * R * T
    // For row vectors v, v' = v * S * R * T applies: scale first, then rotate,
    // then translate Left-to-right multiplication order equals order of
    // application
    return mat4_mul_z(mat4_mul_z(s, rot_mat), t);
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_get_transform_euler_z: Creates 4x4 transform matrix from translation,
// euler rotation, and scale (row-major).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt mat4_get_transform_euler_z(vec3_zt translate, vec3_zt euler_rot, vec3_zt sca)
{
    mat4_zt t   = mat4_translate_z(translate);
    mat4_zt rx  = mat4_rotate_x_z(euler_rot.x);
    mat4_zt ry  = mat4_rotate_y_z(euler_rot.y);
    mat4_zt rz  = mat4_rotate_z_z(euler_rot.z);
    mat4_zt s   = mat4_scale_z(sca);

    mat4_zt rot = mat4_mul_z(mat4_mul_z(rz, ry), rx);
    // Transform composition: S * R * T
    // For row vectors v, v' = v * S * R * T applies: scale first, then rotate,
    // then translate Left-to-right multiplication order equals order of
    // application
    return mat4_mul_z(mat4_mul_z(s, rot), t);
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_model_to_nrm_z: Extracts 3x3 normal matrix from 4x4 model matrix.
// =========================================================================================================================================
// =========================================================================================================================================
mat3_zt mat4_model_to_nrm_z(mat4_zt model_mat)
{
    mat4_zt inv        = mat4_inverse_z(model_mat);
    mat4_zt transposed = mat4_transpose_z(inv);

    mat3_zt nrm;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            nrm.f[i][j] = transposed.f[i][j];
        }
    }

    return nrm;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_to_ivec2_z: Converts vec2 to ivec2 by truncating components.
// =========================================================================================================================================
// =========================================================================================================================================
ivec2_zt vec2_to_ivec2_z(vec2_zt vec)
{
    return (ivec2_zt){(int)truncf(vec.x), (int)truncf(vec.y)};
}

// =========================================================================================================================================
// =========================================================================================================================================
// Spherical coordinates
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// math_cartesian_to_polar_z: Converts Cartesian coordinates to spherical
// coordinates.
// =========================================================================================================================================
// =========================================================================================================================================
spherical_coords_zt math_cartesian_to_polar_z(vec3_zt cartesian)
{
    float radius  = vec3_length_z(cartesian);
    float azimuth = atan2f(cartesian.y, cartesian.x);
    float polar   = (radius > 0.0f) ? acosf(cartesian.z / radius) : 0.0f;

    return (spherical_coords_zt){(double)radius, (double)azimuth, (double)polar};
}

// =========================================================================================================================================
// =========================================================================================================================================
// math_polar_to_cartesian_z: Converts spherical coordinates to Cartesian
// coordinates.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt math_polar_to_cartesian_z(spherical_coords_zt polar)
{
    float radius          = (float)polar.radius;
    float azimuth         = (float)polar.azimuth;
    float polar_angle     = (float)polar.polar;

    float sin_polar_angle = sinf(polar_angle);
    float x               = radius * sin_polar_angle * cosf(azimuth);
    float y               = radius * sin_polar_angle * sinf(azimuth);
    float z               = radius * cosf(polar_angle);

    return (vec3_zt){x, y, z};
}

// =========================================================================================================================================
// =========================================================================================================================================
// math_are_parallel_z: Checks if two vec3 vectors are parallel.
// =========================================================================================================================================
// =========================================================================================================================================
bool math_are_parallel_z(vec3_zt v1, vec3_zt v2)
{
    vec3_zt cross = vec3_cross_z(v1, v2);
    float len2    = vec3_length2_z(cross);
    return len2 < 0.0001f;
}

// =========================================================================================================================================
// =========================================================================================================================================
// Intersection
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// intersection_result_make_z: Creates intersection result with hit and
// distance.
// =========================================================================================================================================
// =========================================================================================================================================
intersection_result_zt intersection_result_make_z(float dist)
{
    intersection_result_zt result;
    result.hit      = true;
    result.distance = dist;
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// intersection_result_miss_z: Creates intersection result indicating a miss.
// =========================================================================================================================================
// =========================================================================================================================================
intersection_result_zt intersection_result_miss_z(void)
{
    intersection_result_zt result;
    result.hit      = false;
    result.distance = 0.0f;
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// intersection_result_lt_z: Compares two intersection results (for sorting).
// =========================================================================================================================================
// =========================================================================================================================================
bool intersection_result_lt_z(intersection_result_zt a, intersection_result_zt b)
{
    if (!a.hit && !b.hit)
    {
        return false;
    }
    if (!a.hit)
    {
        return false;
    }
    if (!b.hit)
    {
        return true;
    }
    return a.distance < b.distance;
}

// =========================================================================================================================================
// =========================================================================================================================================
// math_check_ray_aabb_intersection_z: Checks ray-AABB intersection using slab
// method.
// =========================================================================================================================================
// =========================================================================================================================================
intersection_result_zt math_check_ray_aabb_intersection_z(vec3_zt ray_position, vec3_zt ray_direction, vec3_zt bb_min, vec3_zt bb_max)
{
    vec3_zt inv_dir;
    inv_dir.x  = ray_direction.x == 0.0f ? 1e20f : 1.0f / ray_direction.x;
    inv_dir.y  = ray_direction.y == 0.0f ? 1e20f : 1.0f / ray_direction.y;
    inv_dir.z  = ray_direction.z == 0.0f ? 1e20f : 1.0f / ray_direction.z;

    float t1   = (bb_min.x - ray_position.x) * inv_dir.x;
    float t2   = (bb_max.x - ray_position.x) * inv_dir.x;
    float t3   = (bb_min.y - ray_position.y) * inv_dir.y;
    float t4   = (bb_max.y - ray_position.y) * inv_dir.y;
    float t5   = (bb_min.z - ray_position.z) * inv_dir.z;
    float t6   = (bb_max.z - ray_position.z) * inv_dir.z;

    float tmin = fmaxf(fmaxf(fminf(t1, t2), fminf(t3, t4)), fminf(t5, t6));
    float tmax = fminf(fminf(fmaxf(t1, t2), fmaxf(t3, t4)), fmaxf(t5, t6));

    if (tmax < 0.0f || tmin > tmax)
    {
        return intersection_result_miss_z();
    }

    float t = tmin < 0.0f ? tmax : tmin;
    return intersection_result_make_z(t);
}

// =========================================================================================================================================
// =========================================================================================================================================
// Utility functions
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// math_proportion_z: Computes proportion i0 / i1 as float.
// =========================================================================================================================================
// =========================================================================================================================================
float math_proportion_z(uint64_t i0, uint64_t i1)
{
    if (i1 == 0)
    {
        return 0.0f;
    }
    return (float)i0 / (float)i1;
}

// =========================================================================================================================================
// =========================================================================================================================================
// Orbit camera
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_init_z: Initializes orbit camera from config.
// =========================================================================================================================================
// =========================================================================================================================================
void orbit_camera_init_z(orbit_camera_zt* p_camera, orbit_camera_config_zt config)
{
    p_camera->position     = config.start_pos;
    p_camera->target_pos   = config.start_target_pos;
    p_camera->vert_fov_deg = config.start_fov;
    p_camera->aspect_ratio = config.aspect_ratio;
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_model_mat_z: Gets model matrix for orbit camera
// (camera-to-world transform).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt orbit_camera_get_model_mat_z(orbit_camera_zt* p_camera)
{
    vec3_zt r = orbit_camera_get_right_axis_z(p_camera);
    vec3_zt f = orbit_camera_get_forward_axis_z(p_camera);
    vec3_zt u = orbit_camera_get_up_axis_z(p_camera);

    // Row-major, row-vector convention:
    // Row 0: right axis (X basis)
    // Row 1: forward axis (Y basis)
    // Row 2: up axis (Z basis)
    // Row 3: position (translation)
    return mat4_from_rows_z((vec4_zt){r.x, r.y, r.z, 0.0f}, (vec4_zt){f.x, f.y, f.z, 0.0f}, (vec4_zt){u.x, u.y, u.z, 0.0f}, (vec4_zt){p_camera->position.x, p_camera->position.y, p_camera->position.z, 1.0f});
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_near_plane_height_z: Computes near plane height from
// distance.
// =========================================================================================================================================
// =========================================================================================================================================
float orbit_camera_get_near_plane_height_z(orbit_camera_zt* p_camera, float near_plane_dist)
{
    float fov_rad = p_camera->vert_fov_deg * 3.14159265358979323846f / 180.0f;
    return 2.0f * near_plane_dist * tanf(fov_rad * 0.5f);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_near_plane_width_z: Computes near plane width from height.
// =========================================================================================================================================
// =========================================================================================================================================
float orbit_camera_get_near_plane_width_z(orbit_camera_zt* p_camera, float near_plane_height)
{
    return near_plane_height * p_camera->aspect_ratio;
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_forward_axis_z: Gets forward axis vector from camera.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt orbit_camera_get_forward_axis_z(orbit_camera_zt* p_camera)
{
    return vec3_normalize_z(vec3_sub_z(p_camera->target_pos, p_camera->position));
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_right_axis_z: Gets right axis vector from camera.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt orbit_camera_get_right_axis_z(orbit_camera_zt* p_camera)
{
    vec3_zt forward = orbit_camera_get_forward_axis_z(p_camera);
    vec3_zt right   = vec3_cross_z(forward, MATH_UP);
    // Handle edge case where forward is parallel to MATH_UP
    if (vec3_length2_z(right) < 0.0001f)
    {
        right = MATH_RIGHT;
    }
    return vec3_normalize_z(right);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_up_axis_z: Gets up axis vector from camera.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt orbit_camera_get_up_axis_z(orbit_camera_zt* p_camera)
{
    vec3_zt forward = orbit_camera_get_forward_axis_z(p_camera);
    vec3_zt right   = orbit_camera_get_right_axis_z(p_camera);
    return vec3_normalize_z(vec3_cross_z(right, forward));
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_view_mat_z: Gets view matrix for orbit camera.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt orbit_camera_get_view_mat_z(orbit_camera_zt* p_camera)
{
    return mat4_look_at_z(p_camera->position, p_camera->target_pos, MATH_UP);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_get_proj_mat_z: Gets projection matrix for orbit camera.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt orbit_camera_get_proj_mat_z(orbit_camera_zt* p_camera, float near_dist, float far_dist)
{
    float fov_rad = p_camera->vert_fov_deg * 3.14159265358979323846f / 180.0f;
    return mat4_perspective_z(fov_rad, p_camera->aspect_ratio, near_dist, far_dist);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_screen_point_to_near_world_z: Converts screen point to world
// position on near plane.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt orbit_camera_screen_point_to_near_world_z(orbit_camera_zt* p_camera, vec2_zt nrm_point, float near_dist, float far_dist)
{
    float height        = orbit_camera_get_near_plane_height_z(p_camera, near_dist);
    float width         = orbit_camera_get_near_plane_width_z(p_camera, height);

    vec3_zt forward     = orbit_camera_get_forward_axis_z(p_camera);
    vec3_zt right       = orbit_camera_get_right_axis_z(p_camera);
    vec3_zt up          = orbit_camera_get_up_axis_z(p_camera);

    vec3_zt near_center = vec3_add_z(p_camera->position, vec3_mul_scalar_z(forward, near_dist));
    vec3_zt offset      = vec3_add_z(vec3_mul_scalar_z(right, (nrm_point.x - 0.5f) * width), vec3_mul_scalar_z(up, (nrm_point.y - 0.5f) * height));

    return vec3_add_z(near_center, offset);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_screen_point_to_ray_dir_z: Converts screen point to ray
// direction.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt orbit_camera_screen_point_to_ray_dir_z(orbit_camera_zt* p_camera, vec2_zt nrm_point, float near_dist, float far_dist)
{
    vec3_zt near_world = orbit_camera_screen_point_to_near_world_z(p_camera, nrm_point, near_dist, far_dist);
    return vec3_normalize_z(vec3_sub_z(near_world, p_camera->position));
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_rotate_z: Rotates orbit camera around target position.
// =========================================================================================================================================
// =========================================================================================================================================
void orbit_camera_rotate_z(orbit_camera_zt* p_camera, vec2_zt delta, float speed)
{
    vec3_zt offset            = vec3_sub_z(p_camera->position, p_camera->target_pos);
    spherical_coords_zt polar = math_cartesian_to_polar_z(offset);
    polar.azimuth             = polar.azimuth - (double)delta.x * (double)speed;
    polar.polar               = polar.polar - (double)delta.y * (double)speed;
    polar.polar               = fmax(0.1, fmin(polar.polar, (double)M_PI - 0.1));
    vec3_zt new_offset        = math_polar_to_cartesian_z(polar);
    p_camera->position        = vec3_add_z(new_offset, p_camera->target_pos);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_pan_z: Slides target and position using the camera up/right
// axes.
// =========================================================================================================================================
// =========================================================================================================================================
void orbit_camera_pan_z(orbit_camera_zt* p_camera, vec2_zt delta, float speed)
{
    vec3_zt up           = orbit_camera_get_up_axis_z(p_camera);
    vec3_zt right        = orbit_camera_get_right_axis_z(p_camera);
    vec3_zt up_offset    = vec3_mul_scalar_z(up, delta.y * speed);
    vec3_zt right_offset = vec3_mul_scalar_z(right, delta.x * speed);
    p_camera->target_pos = vec3_add_z(p_camera->target_pos, up_offset);
    p_camera->target_pos = vec3_sub_z(p_camera->target_pos, right_offset);
    p_camera->position   = vec3_add_z(p_camera->position, up_offset);
    p_camera->position   = vec3_sub_z(p_camera->position, right_offset);
}

// =========================================================================================================================================
// =========================================================================================================================================
// orbit_camera_zoom_z: Moves the camera along the view direction clamped to a
// minimal distance.
// =========================================================================================================================================
// =========================================================================================================================================
void orbit_camera_zoom_z(orbit_camera_zt* p_camera, float delta, float speed)
{
    vec3_zt dir      = vec3_normalize_z(vec3_sub_z(p_camera->position, p_camera->target_pos));
    vec3_zt move_vec = vec3_mul_scalar_z(vec3_neg_z(dir), delta * speed);
    vec3_zt new_pos  = vec3_add_z(p_camera->position, move_vec);
    float new_dist   = vec3_length_z(vec3_sub_z(new_pos, p_camera->target_pos));
    if (new_dist < 0.01f && delta > 0.0f)
    {
        return;
    }
    p_camera->position = new_pos;
}

// =========================================================================================================================================
// =========================================================================================================================================
// Free camera
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_init_z: Initialises free camera from config.
// =========================================================================================================================================
// =========================================================================================================================================
void free_camera_init_z(free_camera_zt* p_camera, free_camera_config_zt config)
{
    p_camera->position     = config.start_pos;
    p_camera->yaw          = config.start_yaw;
    p_camera->pitch        = config.start_pitch;
    p_camera->vert_fov_deg = config.start_fov;
    p_camera->aspect_ratio = config.aspect_ratio;
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_forward_axis_z: Gets forward axis vector from camera orientation.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt free_camera_get_forward_axis_z(free_camera_zt* p_camera)
{
    float cos_pitch = cosf(p_camera->pitch);
    float sin_pitch = sinf(p_camera->pitch);
    float cos_yaw   = cosf(p_camera->yaw);
    float sin_yaw   = sinf(p_camera->yaw);

    vec3_zt forward;
    forward.x = sin_yaw * cos_pitch;
    forward.y = cos_yaw * cos_pitch;
    forward.z = sin_pitch;
    return vec3_normalize_z(forward);
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_right_axis_z: Gets right axis vector from camera orientation.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt free_camera_get_right_axis_z(free_camera_zt* p_camera)
{
    vec3_zt forward = free_camera_get_forward_axis_z(p_camera);
    vec3_zt right   = vec3_cross_z(forward, MATH_UP);
    // Handle edge case where forward is parallel to MATH_UP
    if (vec3_length2_z(right) < 0.0001f)
    {
        right = MATH_RIGHT;
    }
    return vec3_normalize_z(right);
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_up_axis_z: Gets up axis vector from camera orientation.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt free_camera_get_up_axis_z(free_camera_zt* p_camera)
{
    vec3_zt forward = free_camera_get_forward_axis_z(p_camera);
    vec3_zt right   = free_camera_get_right_axis_z(p_camera);
    return vec3_normalize_z(vec3_cross_z(right, forward));
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_model_mat_z: Gets model matrix for free camera (camera-to-world transform).
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt free_camera_get_model_mat_z(free_camera_zt* p_camera)
{
    vec3_zt r = free_camera_get_right_axis_z(p_camera);
    vec3_zt f = free_camera_get_forward_axis_z(p_camera);
    vec3_zt u = free_camera_get_up_axis_z(p_camera);
    return mat4_from_rows_z((vec4_zt){r.x, r.y, r.z, 0.0f}, (vec4_zt){f.x, f.y, f.z, 0.0f}, (vec4_zt){u.x, u.y, u.z, 0.0f}, (vec4_zt){p_camera->position.x, p_camera->position.y, p_camera->position.z, 1.0f});
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_near_plane_height_z: Computes near plane height from distance.
// =========================================================================================================================================
// =========================================================================================================================================
float free_camera_get_near_plane_height_z(free_camera_zt* p_camera, float near_plane_dist)
{
    float fov_rad = p_camera->vert_fov_deg * 3.14159265358979323846f / 180.0f;
    return 2.0f * near_plane_dist * tanf(fov_rad * 0.5f);
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_near_plane_width_z: Computes near plane width from height.
// =========================================================================================================================================
// =========================================================================================================================================
float free_camera_get_near_plane_width_z(free_camera_zt* p_camera, float near_plane_height)
{
    return near_plane_height * p_camera->aspect_ratio;
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_view_mat_z: Gets view matrix for free camera.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt free_camera_get_view_mat_z(free_camera_zt* p_camera)
{
    vec3_zt forward = free_camera_get_forward_axis_z(p_camera);
    vec3_zt target  = vec3_add_z(p_camera->position, forward);
    return mat4_look_at_z(p_camera->position, target, MATH_UP);
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_get_proj_mat_z: Gets projection matrix for free camera.
// =========================================================================================================================================
// =========================================================================================================================================
mat4_zt free_camera_get_proj_mat_z(free_camera_zt* p_camera, float near_dist, float far_dist)
{
    float fov_rad = p_camera->vert_fov_deg * 3.14159265358979323846f / 180.0f;
    return mat4_perspective_z(fov_rad, p_camera->aspect_ratio, near_dist, far_dist);
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_screen_point_to_near_world_z: Converts screen point to world position on near plane.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt free_camera_screen_point_to_near_world_z(free_camera_zt* p_camera, vec2_zt nrm_point, float near_dist, float far_dist)
{
    float height        = free_camera_get_near_plane_height_z(p_camera, near_dist);
    float width         = free_camera_get_near_plane_width_z(p_camera, height);

    vec3_zt forward     = free_camera_get_forward_axis_z(p_camera);
    vec3_zt right       = free_camera_get_right_axis_z(p_camera);
    vec3_zt up          = free_camera_get_up_axis_z(p_camera);

    vec3_zt near_center = vec3_add_z(p_camera->position, vec3_mul_scalar_z(forward, near_dist));
    vec3_zt offset      = vec3_add_z(vec3_mul_scalar_z(right, (nrm_point.x - 0.5f) * width), vec3_mul_scalar_z(up, (nrm_point.y - 0.5f) * height));

    return vec3_add_z(near_center, offset);
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_screen_point_to_ray_dir_z: Converts screen point to ray direction.
// =========================================================================================================================================
// =========================================================================================================================================
vec3_zt free_camera_screen_point_to_ray_dir_z(free_camera_zt* p_camera, vec2_zt nrm_point, float near_dist, float far_dist)
{
    vec3_zt near_world = free_camera_screen_point_to_near_world_z(p_camera, nrm_point, near_dist, far_dist);
    return vec3_normalize_z(vec3_sub_z(near_world, p_camera->position));
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_rotate_z: Rotates free camera by adjusting yaw and pitch.
// =========================================================================================================================================
// =========================================================================================================================================
void free_camera_rotate_z(free_camera_zt* p_camera, vec2_zt delta, float speed)
{
    p_camera->yaw   = p_camera->yaw + delta.x * speed;
    p_camera->pitch = p_camera->pitch - delta.y * speed;

    // Clamp pitch to avoid gimbal lock (slightly less than 90 degrees)
    const float max_pitch = (float)M_PI * 0.5f - 0.01f;
    if (p_camera->pitch > max_pitch)
    {
        p_camera->pitch = max_pitch;
    }
    if (p_camera->pitch < -max_pitch)
    {
        p_camera->pitch = -max_pitch;
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// free_camera_move_z: Moves free camera. Direction components: x=right (local), y=forward (local), z=up (world).
// =========================================================================================================================================
// =========================================================================================================================================
void free_camera_move_z(free_camera_zt* p_camera, vec3_zt direction, float speed)
{
    vec3_zt forward = free_camera_get_forward_axis_z(p_camera);
    vec3_zt right   = free_camera_get_right_axis_z(p_camera);

    vec3_zt movement = vec3_mul_scalar_z(right, direction.x * speed);
    movement         = vec3_add_z(movement, vec3_mul_scalar_z(forward, direction.y * speed));
    movement         = vec3_add_z(movement, vec3_mul_scalar_z(MATH_UP, direction.z * speed));

    p_camera->position = vec3_add_z(p_camera->position, movement);
}

// =========================================================================================================================================
// =========================================================================================================================================
// Splines
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// bezier_point_z: Evaluates a cubic Bzier curve at parameter t using four
// control points.
// =========================================================================================================================================
// =========================================================================================================================================
static vec2_zt bezier_point_z(const vec2_zt cp[4], float t)
{
    float u        = 1.0f - t;
    float b0       = u * u * u;
    float b1       = 3.0f * u * u * t;
    float b2       = 3.0f * u * t * t;
    float b3       = t * t * t;
    vec2_zt result = vec2_add_z(vec2_add_z(vec2_mul_scalar_z(cp[0], b0), vec2_mul_scalar_z(cp[1], b1)), vec2_add_z(vec2_mul_scalar_z(cp[2], b2), vec2_mul_scalar_z(cp[3], b3)));
    return result;
}

// =========================================================================================================================================
// =========================================================================================================================================
// bezier_tangent_z: Computes the derivative of a cubic Bzier curve at
// parameter t.
// =========================================================================================================================================
// =========================================================================================================================================
static vec2_zt bezier_tangent_z(const vec2_zt cp[4], float t)
{
    float u       = 1.0f - t;
    vec2_zt term1 = vec2_mul_scalar_z(vec2_sub_z(cp[1], cp[0]), 3.0f * u * u);
    vec2_zt term2 = vec2_mul_scalar_z(vec2_sub_z(cp[2], cp[1]), 6.0f * u * t);
    vec2_zt term3 = vec2_mul_scalar_z(vec2_sub_z(cp[3], cp[2]), 3.0f * t * t);
    return vec2_add_z(vec2_add_z(term1, term2), term3);
}

// =========================================================================================================================================
// =========================================================================================================================================
// splines_sample_bezier_tris_z: Samples cubic Bezier curve into triangles.
// =========================================================================================================================================
// =========================================================================================================================================
uint32_t splines_sample_bezier_tris_z(vec2_zt screen_size, const vec2_zt cp[4], int segments, float width_pixels, vec2_zt* out_triangles, uint32_t out_capacity)
{
    // =============================================================================================
    // =============================================================================================
    // Validate inputs.
    // =============================================================================================
    // =============================================================================================
    {
        fatal_check_z(cp, "cp is null");
        fatal_check_z(out_triangles, "out_triangles is null");
    }

    // =============================================================================================
    // =============================================================================================
    // Validate segments and check capacity.
    // =============================================================================================
    // =============================================================================================
    {
        if (segments <= 0)
        {
            return 0;
        }
        if (segments > 255)
        {
            return 0;
        }
        // Each segment produces 2 triangles (6 vertices)
        uint32_t required_vertices = (uint32_t)segments * 6;
        if (out_capacity < required_vertices)
        {
            return 0;
        }
    }

    // =============================================================================================
    // =============================================================================================
    // Generate left and right points along the curve.
    // =============================================================================================
    // =============================================================================================
    vec2_zt left[256];
    vec2_zt right[256];
    vec2_zt last_normal_px = {0.0f, 1.0f}; // fallback if tangent degenerate

    for (int i = 0; i <= segments; ++i)
    {
        float t            = (float)i / (float)segments;
        vec2_zt p          = bezier_point_z(cp, t);

        // Compute tangent, move to pixel space
        vec2_zt tangent    = bezier_tangent_z(cp, t);
        vec2_zt tangent_px = {tangent.x * screen_size.x, tangent.y * screen_size.y};

        // Perpendicular in pixel space
        vec2_zt normal_px  = {-tangent_px.y, tangent_px.x};
        float len_px       = vec2_length_z(normal_px);
        if (len_px != 0.0f)
        {
            normal_px      = vec2_div_scalar_z(normal_px, len_px);
            last_normal_px = normal_px;
        }
        else
        {
            normal_px = last_normal_px;
        }

        // Offset in pixel space, then convert back to normalized
        vec2_zt offset_px = vec2_mul_scalar_z(normal_px, width_pixels * 0.5f);
        vec2_zt offset    = {offset_px.x / screen_size.x, offset_px.y / screen_size.y};

        left[i]           = vec2_sub_z(p, offset);
        right[i]          = vec2_add_z(p, offset);
    }

    // =============================================================================================
    // =============================================================================================
    // Generate triangles from left/right points.
    // =============================================================================================
    // =============================================================================================
    uint32_t vertex_count = 0;
    for (int i = 0; i < segments; ++i)
    {
        out_triangles[vertex_count++] = left[i];
        out_triangles[vertex_count++] = right[i];
        out_triangles[vertex_count++] = right[i + 1];
        out_triangles[vertex_count++] = left[i];
        out_triangles[vertex_count++] = right[i + 1];
        out_triangles[vertex_count++] = left[i + 1];
    }

    return vertex_count;
}

// =========================================================================================================================================
// =========================================================================================================================================
// Normal and tangent calculation
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// calc_nrms_z: Calculates normals from vertex positions.
// =========================================================================================================================================
// =========================================================================================================================================
void calc_nrms_z(const float* positions, uint32_t vertex_count, float* normals)
{
    for (uint32_t i = 0; i < vertex_count; i += 3)
    {
        vec3_zt v0               = {positions[i * 3 + 0], positions[i * 3 + 1], positions[i * 3 + 2]};
        vec3_zt v1               = {positions[(i + 1) * 3 + 0], positions[(i + 1) * 3 + 1], positions[(i + 1) * 3 + 2]};
        vec3_zt v2               = {positions[(i + 2) * 3 + 0], positions[(i + 2) * 3 + 1], positions[(i + 2) * 3 + 2]};

        vec3_zt e1               = vec3_sub_z(v1, v0);
        vec3_zt e2               = vec3_sub_z(v2, v0);
        vec3_zt nrm              = vec3_normalize_z(vec3_cross_z(e1, e2));

        normals[i * 3 + 0]       = nrm.x;
        normals[i * 3 + 1]       = nrm.y;
        normals[i * 3 + 2]       = nrm.z;
        normals[(i + 1) * 3 + 0] = nrm.x;
        normals[(i + 1) * 3 + 1] = nrm.y;
        normals[(i + 1) * 3 + 2] = nrm.z;
        normals[(i + 2) * 3 + 0] = nrm.x;
        normals[(i + 2) * 3 + 1] = nrm.y;
        normals[(i + 2) * 3 + 2] = nrm.z;
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// calc_tans_z: Calculates tangents from vertex positions and UVs.
// =========================================================================================================================================
// =========================================================================================================================================
void calc_tans_z(const float* positions, const float* uvs, uint32_t vertex_count, float* tangents)
{
    for (uint32_t i = 0; i < vertex_count; i += 3)
    {
        vec3_zt v0        = {positions[i * 3 + 0], positions[i * 3 + 1], positions[i * 3 + 2]};
        vec3_zt v1        = {positions[(i + 1) * 3 + 0], positions[(i + 1) * 3 + 1], positions[(i + 1) * 3 + 2]};
        vec3_zt v2        = {positions[(i + 2) * 3 + 0], positions[(i + 2) * 3 + 1], positions[(i + 2) * 3 + 2]};

        vec2_zt uv0       = {uvs[i * 2 + 0], uvs[i * 2 + 1]};
        vec2_zt uv1       = {uvs[(i + 1) * 2 + 0], uvs[(i + 1) * 2 + 1]};
        vec2_zt uv2       = {uvs[(i + 2) * 2 + 0], uvs[(i + 2) * 2 + 1]};

        vec3_zt e1        = vec3_sub_z(v1, v0);
        vec3_zt e2        = vec3_sub_z(v2, v0);
        vec2_zt delta_uv1 = vec2_sub_z(uv1, uv0);
        vec2_zt delta_uv2 = vec2_sub_z(uv2, uv0);

        float f           = 1.0f / (delta_uv1.x * delta_uv2.y - delta_uv2.x * delta_uv1.y);
        vec3_zt tan;
        tan.x                     = f * (delta_uv2.y * e1.x - delta_uv1.y * e2.x);
        tan.y                     = f * (delta_uv2.y * e1.y - delta_uv1.y * e2.y);
        tan.z                     = f * (delta_uv2.y * e1.z - delta_uv1.y * e2.z);
        tan                       = vec3_normalize_z(tan);

        tangents[i * 3 + 0]       = tan.x;
        tangents[i * 3 + 1]       = tan.y;
        tangents[i * 3 + 2]       = tan.z;
        tangents[(i + 1) * 3 + 0] = tan.x;
        tangents[(i + 1) * 3 + 1] = tan.y;
        tangents[(i + 1) * 3 + 2] = tan.z;
        tangents[(i + 2) * 3 + 0] = tan.x;
        tangents[(i + 2) * 3 + 1] = tan.y;
        tangents[(i + 2) * 3 + 2] = tan.z;
    }
}

// =========================================================================================================================================
// =========================================================================================================================================
// String conversion
// =========================================================================================================================================
// =========================================================================================================================================

// =========================================================================================================================================
// =========================================================================================================================================
// vec2_to_string_z: Converts vec2 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* vec2_to_string_z(vec2_zt v, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "vec2(%.3f, %.3f)", v.x, v.y);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec3_to_string_z: Converts vec3 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* vec3_to_string_z(vec3_zt v, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "vec3(%.3f, %.3f, %.3f)", v.x, v.y, v.z);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// vec4_to_string_z: Converts vec4 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* vec4_to_string_z(vec4_zt v, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "vec4(%.3f, %.3f, %.3f, %.3f)", v.x, v.y, v.z, v.w);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec2_to_string_z: Converts ivec2 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* ivec2_to_string_z(ivec2_zt v, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "ivec2(%d, %d)", v.x, v.y);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec3_to_string_z: Converts ivec3 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* ivec3_to_string_z(ivec3_zt v, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "ivec3(%d, %d, %d)", v.x, v.y, v.z);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// ivec4_to_string_z: Converts ivec4 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* ivec4_to_string_z(ivec4_zt v, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "ivec4(%d, %d, %d, %d)", v.x, v.y, v.z, v.w);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// quat_to_string_z: Converts quaternion to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* quat_to_string_z(quat_zt q, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "quat(%.3f, %.3f, %.3f, %.3f)", q.x, q.y, q.z, q.w);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat3_to_string_z: Converts mat3 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* mat3_to_string_z(mat3_zt m, char* buf, size_t buf_size)
{
    snprintf(
        buf,
        buf_size,
        "mat3(\n"
        "  [%.3f, %.3f, %.3f]\n"
        "  [%.3f, %.3f, %.3f]\n"
        "  [%.3f, %.3f, %.3f]\n"
        ")",
        m.f[0][0],
        m.f[0][1],
        m.f[0][2],
        m.f[1][0],
        m.f[1][1],
        m.f[1][2],
        m.f[2][0],
        m.f[2][1],
        m.f[2][2]
    );
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// mat4_to_string_z: Converts mat4 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* mat4_to_string_z(mat4_zt m, char* buf, size_t buf_size)
{
    snprintf(
        buf,
        buf_size,
        "mat4(\n"
        "  [%.3f, %.3f, %.3f, %.3f]\n"
        "  [%.3f, %.3f, %.3f, %.3f]\n"
        "  [%.3f, %.3f, %.3f, %.3f]\n"
        "  [%.3f, %.3f, %.3f, %.3f]\n"
        ")",
        m.f[0][0],
        m.f[0][1],
        m.f[0][2],
        m.f[0][3],
        m.f[1][0],
        m.f[1][1],
        m.f[1][2],
        m.f[1][3],
        m.f[2][0],
        m.f[2][1],
        m.f[2][2],
        m.f[2][3],
        m.f[3][0],
        m.f[3][1],
        m.f[3][2],
        m.f[3][3]
    );
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// bb2_to_string_z: Converts bb2 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* bb2_to_string_z(bb2_zt bb, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "bb2(min=vec2(%.3f, %.3f), max=vec2(%.3f, %.3f))", bb.min.x, bb.min.y, bb.max.x, bb.max.y);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// bb3_to_string_z: Converts bb3 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* bb3_to_string_z(bb3_zt bb, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "bb3(min=vec3(%.3f, %.3f, %.3f), max=vec3(%.3f, %.3f, %.3f))", bb.min.x, bb.min.y, bb.min.z, bb.max.x, bb.max.y, bb.max.z);
    return buf;
}

// =========================================================================================================================================
// =========================================================================================================================================
// bb4_to_string_z: Converts bb4 to string representation.
// =========================================================================================================================================
// =========================================================================================================================================
const char* bb4_to_string_z(bb4_zt bb, char* buf, size_t buf_size)
{
    snprintf(buf, buf_size, "bb4(min=vec4(%.3f, %.3f, %.3f, %.3f), max=vec4(%.3f, %.3f, %.3f, %.3f))", bb.min.x, bb.min.y, bb.min.z, bb.min.w, bb.max.x, bb.max.y, bb.max.z, bb.max.w);
    return buf;
}